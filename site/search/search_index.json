{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cryptopal Rust Challenge Implementation Welcome to the official documentation of my Cryptopal project. This repository contains my implementation of the Cryptopal challenges available at https://cryptopals.com/ . About Cryptopals If you're unfamiliar, the Cryptopals challenges are designed to teach cryptography through practical problem-solving. According to the authors: \"This is a different way to learn about crypto than taking a class or reading a book. We give you problems to solve. They're derived from weaknesses in real-world systems and modern cryptographic constructions. We provide enough information to learn the underlying concepts yourself. When you finish, you'll have gained a solid understanding of how cryptosystems are built and how they can be attacked.\" Why I Built This I decided to showcase my work on these challenges for the following reasons: Passion for the Project : I find the Cryptopal challenges engaging and educational. Lack of Rust Implementations : At the time of writing, existing public repositories with Rust implementations are limited in scope or completeness. Self-Learning and Growth : I want to demonstrate my progress in Rust programming and cryptography by sharing my solutions. What You Will Find Here Feel free to explore the repository using the left navigation. It covers: Installation Instructions : How to set up and run the project locally. Challenge Overview : How each challenge works and the approach I took. Running Challenges : How to execute individual challenges or entire sets. Cryptographic Primitives : Explanations of the core cryptographic concepts used throughout the challenges.","title":"Home"},{"location":"#cryptopal-rust-challenge-implementation","text":"Welcome to the official documentation of my Cryptopal project. This repository contains my implementation of the Cryptopal challenges available at https://cryptopals.com/ .","title":"Cryptopal Rust Challenge Implementation"},{"location":"#about-cryptopals","text":"If you're unfamiliar, the Cryptopals challenges are designed to teach cryptography through practical problem-solving. According to the authors: \"This is a different way to learn about crypto than taking a class or reading a book. We give you problems to solve. They're derived from weaknesses in real-world systems and modern cryptographic constructions. We provide enough information to learn the underlying concepts yourself. When you finish, you'll have gained a solid understanding of how cryptosystems are built and how they can be attacked.\"","title":"About Cryptopals"},{"location":"#why-i-built-this","text":"I decided to showcase my work on these challenges for the following reasons: Passion for the Project : I find the Cryptopal challenges engaging and educational. Lack of Rust Implementations : At the time of writing, existing public repositories with Rust implementations are limited in scope or completeness. Self-Learning and Growth : I want to demonstrate my progress in Rust programming and cryptography by sharing my solutions.","title":"Why I Built This"},{"location":"#what-you-will-find-here","text":"Feel free to explore the repository using the left navigation. It covers: Installation Instructions : How to set up and run the project locally. Challenge Overview : How each challenge works and the approach I took. Running Challenges : How to execute individual challenges or entire sets. Cryptographic Primitives : Explanations of the core cryptographic concepts used throughout the challenges.","title":"What You Will Find Here"},{"location":"installation/","text":"Installation Open your terminal or command prompt and run the following commands: git clone https://github.com/Adrien-roy/cryptopal_rust.git cd cryptopal_rust Installing Rust with Package Managers Install Rust using your preferred package manager: Example for Ubuntu/Debian sudo apt install rustc cargo Example for Fedora sudo dnf install rust Example for Arch Linux sudo pacman -S rust Building and Testing Once Rust is installed, build and test your project: cargo build cargo test","title":"Installation"},{"location":"installation/#installation","text":"Open your terminal or command prompt and run the following commands: git clone https://github.com/Adrien-roy/cryptopal_rust.git cd cryptopal_rust Installing Rust with Package Managers Install Rust using your preferred package manager:","title":"Installation"},{"location":"installation/#example-for-ubuntudebian","text":"sudo apt install rustc cargo","title":"Example for Ubuntu/Debian"},{"location":"installation/#example-for-fedora","text":"sudo dnf install rust","title":"Example for Fedora"},{"location":"installation/#example-for-arch-linux","text":"sudo pacman -S rust Building and Testing Once Rust is installed, build and test your project: cargo build cargo test","title":"Example for Arch Linux"},{"location":"set1/","text":"set 1 this is the really start this was mostly a way for me to learn the basics of rust the exercises are the following : Convert hex to base64 Fixed XOR Single-byte XOR cipher Detect single-character XOR Implement repeating-key XOR Break repeating-key XOR AES in ECB mode Detect AES in ECB mode For this set I needed to do conversion between base64 , hexadecimal, or raw bite: one of the first decision was to treat every string of character as vectors of 8 bits , to skip all issue with the miriads of ways to encode characters. This solution also makes it easy to implement new encoding method later on if needed . I personnaly come from C so I would generally use array , but vector are a much more logical way of handling strings so no complain here . The xor operand is easy to use I would normally do a for loop but here the map operator seemed appropriate I therefore used it . now the the actuall cryptography : Break repeating-key XOR trois fonctions sont necessaire hamming distance The Hamming distance calculation measures how many bits differ between two text segments by counting the bits that are different. In cryptography, this distance is useful for estimating the key size in a Vigen\u00e8re cipher because segments of the same length containing the same key tend to have lower Hamming distances. By comparing these normalized distances for different segment lengths, you can guess the likely length of the key. Since the alphabet used consists of 26 letters among 256 possible characters, the Hamming distance is a good indicator for determining the segment size during a cryptanalysis. interestingly even if we had only 26 possible characters this would still work on a much bigger sample size because all letters are not the same frequency . this function let us easily guess key size Vigenere now that the key length is known the message is broken into several groups based on the length of the key. in our case the key has a length of 29 we therefore have 29 different group with a key made of a single character . this can now be easily broken by itterating each character and scoring each solution by the number of common letters logically the correct text is the one that has the most of common letter . what is interesting is that almost every criptography technique until set 5 will use the same scoring technique . Detect and Break ECB mode","title":"Set 1"},{"location":"set1/#set-1","text":"this is the really start this was mostly a way for me to learn the basics of rust the exercises are the following : Convert hex to base64 Fixed XOR Single-byte XOR cipher Detect single-character XOR Implement repeating-key XOR Break repeating-key XOR AES in ECB mode Detect AES in ECB mode For this set I needed to do conversion between base64 , hexadecimal, or raw bite: one of the first decision was to treat every string of character as vectors of 8 bits , to skip all issue with the miriads of ways to encode characters. This solution also makes it easy to implement new encoding method later on if needed . I personnaly come from C so I would generally use array , but vector are a much more logical way of handling strings so no complain here . The xor operand is easy to use I would normally do a for loop but here the map operator seemed appropriate I therefore used it . now the the actuall cryptography :","title":"set 1"},{"location":"set1/#break-repeating-key-xor","text":"trois fonctions sont necessaire","title":"Break repeating-key XOR"},{"location":"set1/#hamming-distance","text":"The Hamming distance calculation measures how many bits differ between two text segments by counting the bits that are different. In cryptography, this distance is useful for estimating the key size in a Vigen\u00e8re cipher because segments of the same length containing the same key tend to have lower Hamming distances. By comparing these normalized distances for different segment lengths, you can guess the likely length of the key. Since the alphabet used consists of 26 letters among 256 possible characters, the Hamming distance is a good indicator for determining the segment size during a cryptanalysis. interestingly even if we had only 26 possible characters this would still work on a much bigger sample size because all letters are not the same frequency . this function let us easily guess key size","title":"hamming distance"},{"location":"set1/#vigenere","text":"now that the key length is known the message is broken into several groups based on the length of the key. in our case the key has a length of 29 we therefore have 29 different group with a key made of a single character . this can now be easily broken by itterating each character and scoring each solution by the number of common letters logically the correct text is the one that has the most of common letter . what is interesting is that almost every criptography technique until set 5 will use the same scoring technique .","title":"Vigenere"},{"location":"set1/#detect-and-break-ecb-mode","text":"","title":"Detect and Break ECB mode"}]}